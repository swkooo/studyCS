# Binary Search (이진 탐색)

---

### Q

- 이진 탐색(Binary Search) 알고리즘의 동작 원리와 핵심 전제 조건은?

---

### A

- 이진 탐색 (Binary Search)
  - 정렬된 배열(Sorted Array)에서 특정 값을 찾는 탐색 알고리즘.
  - 탐색 범위를 절반씩 효율적으로 줄여나가며 목표 값을 검색.

- #### 핵심 전제 조건
  - 데이터는 반드시 오름차순 또는 내림차순으로 정렬되어 있어야 함.

- #### 동작 원리
  1.  배열의 시작(start), 끝(end) 인덱스를 지정하고 중간(mid) 인덱스를 계산.
  2.  중간(mid) 위치의 값과 찾고자 하는 목표 값을 비교.
  3.  `중간 값 > 목표 값`: 목표는 왼쪽에 있으므로, `end = mid - 1`로 범위를 좁힘.
  4.  `중간 값 < 목표 값`: 목표는 오른쪽에 있으므로, `start = mid + 1`로 범위를 좁힘.
  5.  `start`가 `end`보다 커지기 전까지 위 과정을 반복.
 
```java
// 예시 코드: 반복문을 이용한 이진 탐색 구현
public int binarySearchIterative(int[] arr, int target) {
    int start = 0;
    int end = arr.length - 1;

    while (start <= end) {
        int mid = start + (end - start) / 2; // 오버플로우 방지

        if (arr[mid] == target) {
            return mid; // 목표 값의 인덱스 반환
        } else if (arr[mid] > target) {
            end = mid - 1; // 왼쪽 부분 탐색
        } else {
            start = mid + 1; // 오른쪽 부분 탐색
        }
    }
    return -1; // 배열에 목표 값이 없는 경우
}
```
또는
`Arrays.binarySearch(arr, target);`
로 간단하게 사용할 수 있다.

- #### 복잡도 비교 분석

| 구분 | 이진 탐색 (Binary Search) | 선형 탐색 (Linear Search) |
| :--- | :--- | :--- |
| 시간 복잡도 | $O(\log n)$ | $O(n)$ |
| 공간 복잡도 | $O(1)$ (반복문) /<br> $O(\log n)$ (재귀) | $O(1)$ |

  - **시간 복잡도 ($O(\log n)$)**
    - 이유: 한 번 비교할 때마다 검색해야 할 데이터의 양이 절반으로 감소함.
    - 효율: 데이터가 2배로 늘어나도 비교 횟수는 1회만 증가. 대용량 데이터에서 $O(n)$인 선형 탐색보다 압도적으로 빠름.

  - **공간 복잡도 ($O(1)$)**
    - 기준: 반복문(Iteration)으로 구현했을 경우.
    - 이유: `start`, `end`, `mid` 등 몇 개의 변수만 사용하므로 추가적인 메모리 공간이 거의 필요 없음.
    - (참고) 재귀(Recursion)로 구현 시, 함수 호출 스택이 $\log n$ 깊이만큼 쌓이므로 공간 복잡도는 $O(\log n)$이 됨.
   
---

### Q

- `Collections.sort()`/`Arrays.sort()`와 `PriorityQueue`의 근본적인 차이 및 각각의 적합한 사용 상황에 대해 설명해주세요.

---

### A

- #### `PriorityQueue<E>`
  - 지정된 우선순위에 따라 요소를 관리하는 큐(Queue) 자료구조.
  - 내부적으로 힙(Heap)으로 구현되어, 우선순위가 가장 높은 요소의 접근 및 관리가 효율적임.
  - 요소 추가(`add`)/제거(`poll`) 시 시간 복잡도는 $O(\log N)$.

- #### `sort()`와 `PriorityQueue`의 차이 및 사용 사례

1.  **`Collections.sort()` / `Arrays.sort()`**
      - **특징**: 정적인 데이터 집합 전체를 **한 번에 정렬**하며, 정렬 후 순서는 고정됨.
      - **시간 복잡도**: $O(N \log N)$.
      - **적합 상황**
        - 전체 데이터의 순위가 필요할 경우.
        - **이진 탐색** 등 정렬된 상태를 전제로 하는 후속 작업이 있을 경우.
        - 데이터의 추가/삭제가 빈번하지 않은 정적 데이터 집합을 다룰 경우.
```java
  // 예시 코드: Arrays.sort()와 람다식을 이용한 2차원 배열 정렬
int[][] intervals = {{1, 5}, {2, 4}, {1, 3}};

// 1순위: 시작점(index 0) 오름차순
// 2순위: 시작점이 같으면 끝점(index 1) 오름차순
Arrays.sort(intervals, (a, b) -> {
    if (a[0] == b[0]) {
        return a[1] - b[1];
    }
    return a[0] - b[0];
});
// 정렬 결과: {{1, 3}, {1, 5}, {2, 4}}
```

2.  **`PriorityQueue` (with Comparator)**
      - **특징**: 데이터 추가/삭제 시마다 정렬 상태(힙 구조)를 **동적으로 유지**함. 전체 정렬이 아닌, 우선순위가 가장 높은 요소를 빠르게 찾는 데 목적이 있음.
      - **시간 복잡도**: 요소 추가/삭제 시 $O(\log N)$.
      - **적합 상황**
        - 실시간으로 유입되는 데이터 중 상위 N개의 값을 유지해야 할 경우.
        - 다익스트라 알고리즘처럼, 처리 대상 중 가장 우선순위가 높은 작업을 반복적으로 선택해야 할 경우.
        - 전체 데이터 정렬은 불필요하고, 우선순위가 가장 높은 요소만 지속적으로 필요한 경우.
```java
// 예시 코드: PriorityQueue를 이용한 정렬(Comparator)
PriorityQueue<int[]> pq = new PriorityQueue<>(
    Comparator.comparingInt((int[] arr) -> arr[1]) // 1차: arr[1] 오름차순
              .thenComparingInt((int[] arr) -> arr[0]) // 2차: arr[0] 오름차순
);

pq.add(new int[] {3, 3});
pq.add(new int[] {3, 7});
pq.add(new int[] {1, 3});

System.out.println(Arrays.toString(pq.poll())); // [1, 3] (가장 작은 값)
System.out.println(Arrays.toString(pq.poll())); // [3, 3]
System.out.println(Arrays.toString(pq.poll())); // [3, 7]
```

- #### `Comparator<T>` 인터페이스
- 객체의 사용자 정의 정렬 기준을 정의하기 위한 함수형 인터페이스임.
- `compare(T o1, T o2)` 추상 메소드를 가지며, 반환값에 따라 두 객체의 순서를 결정함.
  - **음수**: `o1`이 `o2`보다 앞 순서.
  - **0**: `o1`과 `o2`의 순서 동일.
  - **양수**: `o1`이 `o2`보다 뒷 순서.

- #### 람다식 (Lambda Expression)
- 익명 클래스 문법을 간결하게 표현하는 문법.
- 하나의 추상 메소드를 가진 함수형 인터페이스(Functional Interface) 구현 시, 코드의 간결성 및 가독성 향상.
