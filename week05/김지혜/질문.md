> ## 1. Bean 은 무엇인가요?

### 답변 
> 💡 **Bean 은 Spring 컨테이너가 대신 생성하고 관리하는 객체이다.**

### Bean 이란? 
Bean 은 객체를 의미한다. 
예를 들어, Spring 이라는 회사에서 직원(객체) 들이 있고 각 직원들마다 하는 일이 있다. (아래는 담당 예시) 

- UserService : 회원가입이나 로그인 처리 담당
- UserRepository :  DB 저장 당담
- EmailSender : 메일 전송 담당

이러한 담당을 하는 “직원들” 이  바로 Bean(빈) 이다.

### 왜 객체를 Bean 이라고 말할까? 
보통 Java 에서는 객체를 생성할 때  아래 코드 처럼 직접 생성해줘야 한다. 
- 위의 예시대로라면 개발자가 *직접 직원을 채용하는 과정* 이라고 해보자.

```java
Userservice userservice = new UserService(); 
```

하지만 Spring 은 객체 생성과 연결(주입) 을 개발자 대신 해주겠다고 한다. 

- 그래서 Spring 을 회사라고 한다면, 그 회사 안에 *인사과* 라는 Spring Container 가 있다.

즉 이 Spring Container (공식 명칭 : ApplicationContext) 가 객체를 대신 생성하고 
필요할 때 서로 연결(주입) 해주는 것이다. 

그래서 결과적으로 Bean 은 그냥 객체를 의미하는 것이 아닌 
**Spring Container 가 관리하는 객체(직원)** 이라고 할 수 있다.

### Bean 의 라이프 사이클 

| 단계  | 실제 Bean 단계          | 비유 설명                              |
| --- | ------------------- | ---------------------------------- |
| 1️⃣ | **생성(create)**      | Spring이 `new`로 객체를 만들고 등록함         |
| 2️⃣ | **의존성 주입(inject)**  | 일할 때 필요한 도구나 협력자 주입 (`@Autowired`) |
| 3️⃣ | **초기화(initialize)** | 일하기 전 사전 준비 (`@PostConstruct` 등)   |
| 4️⃣ | **사용(use)**         | 실제로 Controller나 Service 로직에서 사용됨   |
| 5️⃣ | **소멸(destroy)**     | 프로그램 종료 시 메모리 정리 (`@PreDestroy`)   |


즉, Bean 은 Spring 이 대신 고용하고, 관리하고, 해고하는 직원 이라고 생각하면 깔끔하다. 


<hr>

> ## 2. Bean 을 등록하는 방법으로 뭐가 있나요?

### 답변 
> 💡 Bean 을 등록하는 방법으로는 3가지가 있습니다. <br> 1. <bean> 태그를 통한 XML 설정으로 등록하는 방법<br> 2. `@Component, @Service, @Repository, @Controller` 같은 어노테이션으로 등록하는 방법 <br> 3. `@Configuration, @Bean` 같이 Java Config 기반으로 등록하는 방법

## Bean 등록 방법

Spring 회사가 직원(Bean) 을 등록하는 방법은 3가지가 있다. 

### 1. XML 설정 방식

이 방식은 스프링 초창기(Spring 2.x) 방식으로 요즘은 거의 쓰지 않지만, <br>
컨테이너가 Bean 을 어떻게 등록하는지 이해하기에 좋다. 

```xml
<!--직접 채용서류(xml 파일) 에 직원 목록을 써서 등록하는 방식 -->
<bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource">
    <property name="url" value="jdbc:mysql://localhost/testdb"/>
    <property name="username" value="root"/>
</bean>
```

### 2. 어노테이션 기반 등록

```java
@Component // " 이 클래스는 직원이야 ! " 라고 스티커(@Component) 를 붙여두는 방식 
public class UserService { ... } 
```

위와 같이 Component 를 붙여서 Bean 을 등록할 수도 있지만 <br>
Bean 의 역할에 맞게 아래와 같이 어노테이션을 붙이기도 한다. 

- `@Controller` : 웹 요청 담당
- `@Service` : 비즈니스 로직 담당
- `@Repository` : DB 담당

- **`@Component` 와 역할에 맞는 어노테이션 의 차이 부가설명**
    
    `@Component` 는 Bean 을 등록하기 위한 어노테이션으로 최상위 개념(부모) 이고 `@Controller, @Service, @Repository` 는 `@Component` 를 상속받은 세부 역할 구분용 어노테이션이다. 
    
    - Controller 소스 예시
    
    ```java
    // Controller.java
    @Target(ElementType.TYPE)
    @Retention(RetentionPolicy.RUNTIME)
    @Documented
    @Component   // ✅ @Component를 상속받음
    public @interface Controller {
        String value() default "";
    }
    
    ```
    

이렇게 붙여두면 Spring 이 컴포넌트 스캔(Component Scan) 을 돌면서 자동으로 등록해준다. 

- **부가 설명**
    
    조금 더 자세히 설명하자면 Spring 의 인사과인 Spring Container(공식 명칭: ApplicationContext) 이 자기 밑에 있는 스캐너(Scanner 직원) 한명 한테 일을 시키는 구조이다. 
    
    ```java
    프로그램 실행
       ↓
    Spring Boot 가 ApplicationContext 생성
       ↓
    ApplicationContext 가 Bean 등록 작업 시작
       ├─ @Configuration 클래스 읽기
       ├─ @Bean 메서드 등록
       └─ @ComponentScan 실행  ← 여기서 자동 등록
              ↓
          ClassPathScanningCandidateComponentProvider (스캐너)
          ├─ @Component, @Service, @Repository, @Controller 붙은 클래스 탐색
          └─ BeanDefinition 으로 변환 후 컨테이너에 등록
    ```
    
    ApplicationContext 가 전체 Bean 등록의 총책임자(인사과장)이고, <br> 
    실제로 classpath 를 뒤져서 어노테이션 붙은 클래스를 찾아내는 일은 ComponentScanner(하위 직원)가 대신 수행하는 구조이다. 
    

### 3. Java Config 방식 (@Configuration + @Bean)

```java
// 개발자가 직접 자바 코드로 직원 등록 명단을 관리하는 방식
@Configuration // 이 클래스는 스프링 설정 파일임을 표시하는 것 
public class AppConfig {
	
	@Bean // 이 메서드가 반환하는 객체를 Bean 으로 등록해달라는 표시 
	public UserService userService() {
		return new UserService(); 
	}

}
```

이 방식은 명시적으로 Bean 을 등록할 때 사용한다. <br>
특히 직접 만든 클래스가 아닌 외부 라이브러리 객체 같은 걸 Bean 으로 등록하고 싶을 때 유용하다. <br>
이 방식은 또한, 어노테이션 기반의 2번째 방식(@ComponentScan) 보다 먼저 실행된다. 

```java
@SpringBootApplication
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

`@SpringBootApplication` 은  내부적으로 `@Configuration` 으로 지정된 클래스를 제일 먼저 읽는다.
